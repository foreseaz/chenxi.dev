---
title: èŠèŠ Rust çš„æ‰€æœ‰æƒ
date: 2023-04-05
slug: "/ownership-in-rust"
tags:
  - Rust
  - Memory
  - Security
  - Programming Language
---

å»å¹´ä¸‹åŠå¹´åœ¨ CMU æœ€åä¸€ä¸ªå­¦æœŸçš„ Practicum ä¸­ï¼Œå¸® Adobe ç§»æ¤ä¸€ä¸ªæµè§ˆå™¨é‡Œçš„å†…å­˜æ³„æ¼æ£€æµ‹å·¥å…· BLeak åˆ° NodeJSï¼Œæˆ‘ä»¬å–åå« [NLeak](https://github.com/nleak/nleak)ï¼Œå®ƒå°†å†…å­˜ä¸­è¿ç»­å‡ æ¬¡çš„ Heap Snapshot åšæ¯”å¯¹ï¼Œæ¥æ‰¾å‡ºå†…å­˜æ³„æ¼çš„æºå¤´å¹¶æ ‡è®°åœ¨ source map ä¸Šï¼Œè¿™ä¸ªç®€å•çš„ PoC å·²ç»å¯ä»¥æ‰¾å‡º NodeJS ä¸€äº›åŸºæœ¬çš„å†…å­˜æ³„æ¼ï¼Œä½†åˆ°å®ç”¨çš„ç¨‹åº¦å¯è°“ä»»é‡é“è¿œã€‚ä¸ç®¡æ˜¯å‘å¸ƒè¿‘äºŒåå¹´çš„ C++ è€ç‰Œçš„å†…å­˜æ£€æµ‹å·¥å…· [Valgrind](https://en.wikipedia.org/wiki/Valgrind) è¿˜æ˜¯å»å¹´ Facebook æ‰å¼€æºçš„æ£€æµ‹ JS å†…å­˜æ³„æ¼çš„ [memlab](https://github.com/facebook/memlab)ï¼Œä»»ä½•è¯­è¨€ç¼–å†™çš„ç¨‹åºï¼Œåªè¦è·‘åœ¨å†¯è¯ºä¾æ›¼ç»“æ„çš„è®¡ç®—æœºä¸Šï¼Œå†…å­˜é—®é¢˜å°±æ˜¯æˆ‘ä»¬è½¯ä»¶å·¥ç¨‹å¸ˆæ°¸è¿œç»•ä¸è¿‡çš„é—®é¢˜ä¹‹ä¸€ã€‚

é‚£ç›¸æ¯”äºå‡ºäº†é—®é¢˜æˆ‘ä»¬ç”¨å·¥å…·å»æ£€æµ‹å’Œè¡¥æ•‘ï¼Œæœ‰æ²¡æœ‰ä»€ä¹ˆå·¥å…·æ˜¯èƒ½å¸®åŠ©æˆ‘ä»¬ä»æºå¤´ä¸Šé¿å…æ‰å¾ˆå¤šå†…å­˜é—®é¢˜çš„å‘¢ï¼ŸRust å¯èƒ½æ˜¯ç°é˜¶æ®µä¸€ä¸ªä¸é”™çš„ç­”æ¡ˆã€‚

**ä¸ºä»€ä¹ˆæˆ‘ä»¬è¯´ Rust èƒ½ç¼–å†™å‡ºå†…å­˜å®‰å…¨çš„åº”ç”¨ï¼Ÿ**

ä¸€èŠåˆ° Rustï¼Œæˆ‘ä»¬æåˆ°çš„ä¸æ˜¯å®ƒåœ¨ bare metal ä¸Šçš„é«˜å¹¶å‘æ€§èƒ½ï¼›ä¸æ˜¯å®ƒçš„ portabilityï¼Œå¯ä»¥ç¼–è¯‘æˆä¸åŒå¹³å°çš„æœºå™¨ç ï¼Œä¹Ÿå¯ä»¥ç¼–è¯‘æˆ WebAssemblyï¼›ä¹Ÿä¸æ˜¯å®ƒçš„å¼€å‘æ•ˆç‡ï¼Œæ¯” C, C++ æ›´æ˜“ä¸Šæ‰‹ï¼Œbulletproof çš„æ ‡å‡†åº“ï¼Œæ˜“ç”¨çš„å·¥å…·é“¾å’Œæ´»è·ƒçš„å¼€æºç¤¾åŒºã€‚è€Œæ˜¯ä»Šå¤©æƒ³èŠèŠçš„å†…å­˜å®‰å…¨ï¼š

Rust èƒ½å¤Ÿä¿è¯å†…å­˜å®‰å…¨ï¼Œå®ƒèƒ½é¿å…å¾ˆå¤š C, C++ ç­‰è¯­è¨€å¸¸è§çš„å†…å­˜é—®é¢˜ï¼šå†…å­˜æ³„æ¼ï¼ŒåŒé‡é‡Šæ”¾ï¼Œå‚æ‚¬æŒ‡é’ˆï¼Œç¼“å†²åŒºæº¢å‡ºï¼Œæœªåˆå§‹åŒ–çš„å†…å­˜ä½¿ç”¨ç­‰ç­‰ã€‚åŒæ—¶ï¼ŒRust ä¹Ÿæä¾›äº†å®‰å…¨çš„æ ‡å‡†åº“å‡½æ•°å’Œå®ï¼Œä»¥å¸®åŠ©å¼€å‘äººå‘˜é¿å…è¿™äº›é”™è¯¯ã€‚è€Œå®ƒå†…å­˜å®‰å…¨çš„ç‰¹æ€§ä¸»è¦å¾—ç›Šäºä¸‰ç‚¹è®¾è®¡ï¼š

1. **æ‰€æœ‰æƒå’Œå€Ÿç”¨ç³»ç»Ÿ**ï¼šRust é€šè¿‡æ‰€æœ‰æƒå’Œå€Ÿç”¨ç³»ç»Ÿæ¥ç®¡ç†å†…å­˜ï¼Œç¡®ä¿åœ¨ç¼–è¯‘æ—¶å°±èƒ½å¤Ÿæ£€æµ‹åˆ°å†…å­˜å®‰å…¨é—®é¢˜ã€‚
2. **ç”Ÿå‘½å‘¨æœŸ**ï¼šRust å¼•å…¥äº†ç”Ÿå‘½å‘¨æœŸçš„æ¦‚å¿µï¼Œç”¨äºç®¡ç†å¼•ç”¨çš„æœ‰æ•ˆæ€§ã€‚ç”Ÿå‘½å‘¨æœŸæè¿°äº†å¼•ç”¨åœ¨ç¨‹åºä¸­å­˜åœ¨çš„æ—¶é—´èŒƒå›´ï¼Œä»¥ç¡®ä¿å¼•ç”¨ä¸ä¼šè¶…å‡ºå®ƒæ‰€å¼•ç”¨çš„å€¼çš„ç”Ÿå‘½å‘¨æœŸã€‚è¿™æœ‰åŠ©äºé¿å…å¼•ç”¨éæ³•æˆ–æ‚¬å‚çš„å€¼ã€‚
3. **é›¶æˆæœ¬æŠ½è±¡**ï¼šRust çš„æŠ½è±¡æœºåˆ¶å…è®¸ç¨‹åºå‘˜ä½¿ç”¨é«˜å±‚æ¬¡çš„è¯­è¨€ç‰¹æ€§ï¼ŒåŒæ—¶ä¸ä¼šç‰ºç‰²æ€§èƒ½ã€‚è¿™æ˜¯é€šè¿‡ä½¿ç”¨ Rust çš„ç¼–è¯‘æ—¶ä»£ç ç”Ÿæˆå’Œä¼˜åŒ–æœºåˆ¶å®ç°çš„ï¼Œè¿™äº›æœºåˆ¶ä½¿å¾—æŠ½è±¡å¯ä»¥è¢«è½¬åŒ–ä¸ºé«˜æ•ˆçš„æœºå™¨ç ã€‚è¿™ç§ä¼˜åŒ–æœºåˆ¶ä½¿å¾— Rust å¯ä»¥æä¾›å†…å­˜å®‰å…¨çš„åŒæ—¶ï¼Œä¹Ÿä¿æŒäº†ä¸ C++ ç­‰è¯­è¨€ç›¸å½“çš„æ€§èƒ½ã€‚

è¿™é‡Œé¢ï¼Œæ‰€æœ‰æƒå’Œå€Ÿç”¨ç³»ç»Ÿæ˜¯æœ€é‡è¦çš„ï¼Œä¹Ÿæ˜¯è¿™æ¬¡è¦å…³æ³¨çš„ï¼Œç”Ÿå‘½å‘¨æœŸå’Œé›¶æˆæœ¬æŠ½è±¡æˆ‘ä¼šåœ¨æœªæ¥çš„åšå®¢ä¸­å†èŠã€‚æˆ‘å°†ç”¨å‡ ä¸ªä¾‹å­æ¥æ…¢æ…¢æ·±å…¥ï¼Œæ¥æ€è€ƒä¸€ä¸‹ä¸ºä»€ä¹ˆ Rust å¼•å…¥äº†æ‰€æœ‰æƒè¿™ä¸ªæ–°æ¦‚å¿µï¼Œå®ƒåˆæ˜¯å¦‚ä½•æ¥å¸®åŠ©è§£å†³ä¸Šé¢çš„å†…å­˜é—®é¢˜çš„ã€‚

# ä¸€åˆ‡ç”±å­—ç¬¦ä¸²èŠèµ·

## è¢«ç¼–è¯‘å™¨å«Œå¼ƒçš„æˆ‘ ğŸ˜–

â€œHeyï¼ä¸ºä»€ä¹ˆè¿æœ€ç®€å•çš„å­—ç¬¦ä¸²æ“ä½œï¼Œéƒ½èƒ½è¢«ç¼–è¯‘å™¨éª‚å¾—ç‹—è¡€æ·‹å¤´ï¼Ÿâ€ å¯èƒ½å¾ˆå¤šåˆšåˆšæ¥è§¦ Rust çš„äººéƒ½ä¼šå’Œæˆ‘æœ‰æ ·çš„æ„Ÿå—ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸‹é¢å‡ ä¸ªç®€å•çš„ä¾‹å­ï¼Œæ¥çœ‹çœ‹ Rust çš„æ‰€æœ‰æƒå’Œå…¶ä»–è¯­è¨€æœ‰ä»€ä¹ˆä¸åŒã€‚

### ä¾‹å­ 1: å˜¿ï¼æˆ‘åªæƒ³æ›´æ–°ä¸‹æˆ‘çš„å­—ç¬¦ä¸²è€Œå·²

```c
fn main() {
    let word = "foo"; // you should add `mut` keyword here
    word = "bar"; // error[E0384]: cannot assign twice to immutable variable `str`
    println!("{}", word);
}
```

è¿™æ˜¯å› ä¸ºåœ¨ Rust ä¸­å®šä¹‰ä¸€ä¸ªå˜é‡æ—¶ï¼Œé»˜è®¤æƒ…å†µä¸‹è¿™ä¸ªå˜é‡æ˜¯ immutable çš„ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬ä¸èƒ½æ”¹å˜å®ƒçš„å€¼ã€‚å¦‚æœæœ‰éœ€è¦ï¼Œå¯ä»¥é€šè¿‡ `mut` å…³é”®å­—æ¥å®šä¹‰å¯å˜å˜é‡ã€‚æ‰€ä»¥ä¸Šé¢åº”è¯¥ä¿®æ”¹æˆ `let mut word = "foo"`ã€‚

### ä¾‹å­ 2ï¼šå˜¿ï¼æˆ‘åªæƒ³æŠŠä¸¤ä¸ªå­—ç¬¦ä¸²æ‹¼æ¥èµ·æ¥è€Œå·²

```c
fn main() {
    let s1 = "Hello";
    let s2 = " World!";
    hello = s1 + s2; // error[E0369]: cannot add `&str` to `&str`
    println!("{}", hello);
}
```

å› ä¸º `&str` æ˜¯æ”¾ç½®äº Stack ä¸Šçš„åˆ‡ç‰‡å¼•ç”¨ï¼Œä¸æ”¯æŒ `+` æ¥æ‹¼æ¥ã€‚å¦‚æœä½ æƒ³è¦æ‹¼æ¥ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œå¯ä»¥å°†è¿™ä¸ªå­—ç¬¦ä¸²è½¬åŒ–æˆå­˜æ”¾åœ¨ Heap ä¸Šçš„ä½¿ç”¨ `String` ç±»å‹ï¼š

```c
fn main() {
    let s1 = String::from("Hello");
    let s2 = String::from(" World!");
    let s3 = s1 + &s2; // Note: left of + must be String and right of + must be &str, but why? Let's talk about it later :)
    println!("{}", s3);
}
```

æˆ‘ä»¬è¿™é‡Œæåˆ°äº† Rust é‡Œéå¸¸é‡è¦çš„ä¸€ä¸ªæ¦‚å¿µï¼šåˆ‡ç‰‡ (Slice)ï¼Œ`&str`ç±»å‹çš„å˜é‡ `s1` å°±æ˜¯ä¸€ä¸ªåˆ‡ç‰‡ï¼Œæˆ‘ä»¬åé¢ä¼šæ›´æ·±å…¥å»ç†è§£å®ƒã€‚

### ä¾‹å­ 3ï¼šå˜¿ï¼æˆ‘è¿˜æƒ³ç”¨ä¹‹å‰çš„å­—ç¬¦ä¸²ï¼Œæ€ä¹ˆå°±ä¸è¡Œäº†ï¼Ÿ

```c
fn main() {
    let s1 = String::from("Hello");
    let s2 = String::from(" World!");
    let s3 = s1 + &s2;
    println!("{} {} {}", s1, s2, s3); // error[E0382]: borrow of moved value: `s1`
}
```

è¿™é‡Œæˆ‘ä»¬å°±å¾—å¼•å…¥ Rust ä¸­æœ€é‡è¦çš„æ¦‚å¿µä¹‹ä¸€ï¼šæ‰€æœ‰æƒã€‚å½“æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå˜é‡æ—¶ï¼ŒRust ä¼šä¸ºå…¶åˆ†é…å†…å­˜ï¼Œå¹¶é€šè¿‡æ‰€æœ‰æƒæœºåˆ¶æ¥ç®¡ç†è¿™äº›å†…å­˜ã€‚æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªè¢«ç§°ä¸ºå…¶ owner çš„å˜é‡ã€‚å½“ owner ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒæ‹¥æœ‰çš„å€¼å°†è¢«é‡Šæ”¾ã€‚æ‰€æœ‰æƒå’Œä½œç”¨åŸŸæ˜¯ä¿è¯å†…å­˜å®‰å…¨çš„å…³é”®æ‰€åœ¨ã€‚

`String` æ˜¯ä¸€ä¸ªæ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ ï¼Œå®ƒåŒ…å«æŒ‡å‘å®é™…å­—ç¬¦ä¸²æ•°æ®çš„æŒ‡é’ˆã€å­—ç¬¦ä¸²é•¿åº¦å’Œå­—ç¬¦ä¸²å®¹é‡ã€‚å½“æˆ‘ä»¬åœ¨ Rust ä¸­ä½¿ç”¨ `+` è¿ç®—ç¬¦æ¥è¿æ¥ä¸¤ä¸ªå­—ç¬¦ä¸²æ—¶ï¼ŒRust ä¼šå°†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²çš„æ‰€æœ‰æƒè½¬ç§»ç»™è¿ç®—ç¬¦ï¼Œäº§ç”Ÿä¸€ä¸ªæ–°çš„ String å¯¹è±¡ã€‚è¿™æ„å‘³ç€æˆ‘ä»¬ä¸èƒ½å†æ¬¡è®¿é—®ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå› ä¸ºå®ƒçš„æ‰€æœ‰æƒå·²ç»è¢«è½¬ç§»äº†ã€‚å¦‚æœæˆ‘ä»¬æƒ³è¦åœ¨æ“ä½œåç»§ç»­ä½¿ç”¨ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ `clone()` æ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„ Stringï¼Œå¹¶åœ¨æ“ä½œåä½¿ç”¨å®ƒã€‚

æ‰€ä»¥è¿™é‡Œå¯ä»¥æ”¹æˆï¼š

```c
fn main() {
    let s1 = String::from("Hello");
    let s2 = String::from(" World!");
    let s3 = s1.clone() + &s2;
    println!("{} {} {}", s1, s2, s3);
}
```

### ä¾‹å­ 4: å˜¿ï¼æˆ‘çš„å­—ç¬¦ä¸²ä¼ è¿›ä¸€ä¸ªå‡½æ•°åå°±è¢«åƒäº†ï¼Ÿå®ƒæ˜¯é»‘æ´ä¹ˆï¼

```c
fn to_uppercase(s: String) -> String {
    return s.to_uppercase()
}

fn main() {
    let my_string = String::from("Hello World!");
    let my_uppercase_string = to_uppercase(my_string);
    println!("Original string: {}", my_string); // error[E0382]: borrow of moved value: `my_string`
    println!("Uppercase string: {}", my_uppercase_string);
}
```

è¿™é‡Œä¹Ÿå’Œä¸Šä¸€ä¸ªä¾‹å­ä¸€æ ·ï¼Œ `my_string` çš„æ‰€æœ‰æƒåœ¨è¿›å…¥å‡½æ•° `to_uppercase` ä¹‹åè½¬ç§»ç»™äº† `s`ï¼Œè€Œå½“ `s` ç¦»å¼€å®ƒçš„ä½œç”¨åŸŸæ—¶ï¼ˆä¹Ÿå°±æ˜¯ `to_uppercase` çš„æœ€åä¸€è¡Œçš„ `return`ï¼‰ï¼Œ Rust ä¼šè®¤ä¸º `s` å·²ä½¿ç”¨å®Œæ¯•ï¼Œå¹¶é‡Šæ”¾åº•å±‚çš„å†…å­˜ã€‚æ‰€ä»¥ Rust åœ¨ç¼–è¯‘æ—¶å°±ä¼šæé†’ï¼Œ`my_string` çš„æ‰€æœ‰æƒå·²ç»è¢« `moved` äº†ï¼Œåœ¨è°ƒç”¨å®Œ `to_uppercase` ä¹‹åå°±ä¸èƒ½å†ç”¨äº†ã€‚è¢«ç¼–è¯‘å™¨éª‚å¤šäº†ä¹‹åï¼Œæˆ‘å€’è§‰å¾—å®ƒå˜å¾—è´´å¿ƒå¯çˆ±èµ·æ¥ï¼Œè€Œä¸” `moved` è¿™ä¸ªå…³é”®è¯ä¹Ÿéå¸¸å½¢è±¡ä¸æ˜¯ä¹ˆï¼Ÿä¹‹å‰çš„æ‰€æœ‰æƒè¢«ç§»èµ°äº†ï¼Œ `my_string`ä¸æ˜¯ My String äº†ã€‚

é‚£è¿™é‡Œé™¤äº†å¯ä»¥ä½¿ç”¨ `my_string.clone()` ä»¥å¤–ï¼Œè¿˜å¯ä»¥ä¼ å…¥ä¸€ä¸ªå¼•ç”¨ `&my_string`ï¼Œæ¥é¿å… `my_string` çš„æ‰€æœ‰æƒè¢«è½¬ç§»ï¼Œè¿™ä¹Ÿå°±æ˜¯å¦ä¸€ä¸ªå¾ˆé‡è¦çš„æ¦‚å¿µï¼š å€Ÿç”¨ ï¼ˆBorrowingï¼‰ã€‚

```c
fn to_uppercase(s: &str) -> String { // `s` is the reference of `my_string`
    return s.to_uppercase() // created a new String and return
}

fn main() {
    let my_string = String::from("Hello World!");
    let my_uppercase_string = to_uppercase(&my_string); // borrowing `my_string`
    println!("Original string: {}", my_string);
    println!("Uppercase string: {}", my_uppercase_string);
}
```

è¿™å‡ ä¸ªç®€å•çš„ä¾‹å­å°±åŒ…å«äº†æˆ‘ä»¬è¦èŠåˆ°çš„å‡ ä¸ªåŸºæœ¬æ¦‚å¿µï¼šåˆ‡ç‰‡ï¼Œå¼•ç”¨å’Œå€Ÿç”¨ï¼Œæ‰€æœ‰æƒã€‚

## æ‰€æœ‰æƒæœºåˆ¶

Rust æ˜¯ä¸€ä¸ªæ²¡æœ‰è¿è¡Œæ—¶åƒåœ¾å›æ”¶çš„è¯­è¨€ï¼Œè¿™ä¿è¯äº†å®ƒèƒ½æˆä¸ºå’Œ C / C++ å¹¶è‚©çš„é«˜æ•ˆçš„ç³»ç»Ÿçº§å¼€å‘è¯­è¨€ã€‚ä½†å®ƒåˆæ¯” C / C++ è¿™ç§æ‰‹åŠ¨ç®¡ç†å†…å­˜çš„è¯­è¨€æ›´åŠ å®‰å…¨ï¼Œè¿™èƒŒåçš„åŸºç¡€æœ‰ä¸¤ç‚¹ï¼šæ‰€æœ‰æƒç³»ç»Ÿå’Œå€Ÿç”¨æ£€æŸ¥æœºåˆ¶ã€‚

### å¤ä¹ èƒŒæ™¯çŸ¥è¯†ï¼šStack å’Œ Heap

å› ä¸ºæˆ‘ä»¬çš„å…³æ³¨ç‚¹åœ¨å†…å­˜ï¼Œæ‰€ä»¥åœ¨ä»‹ç»æ‰€æœ‰æƒä¸‰åŸåˆ™ä¹‹å‰æˆ‘ä»¬å¯ä»¥ç®€å•å¤ä¹ ä¸€ä¸‹ Stack å’Œ Heap çš„æ¦‚å¿µã€‚è¿™é‡Œæ¬å‡ºæˆ‘ä»¬çš„ CSAPPï¼š

![memory_struct.jpg](./memory_struct.jpg)

åœ¨å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€ä¸­ï¼Œåƒ Javaã€Cã€C++ ç­‰ï¼ŒåŸå§‹æ•°æ®ç±»å‹çš„å˜é‡ï¼Œå‡½æ•°è°ƒç”¨çš„ä¸Šå†™æ–‡ç­‰ç­‰ä¼šè¢«å­˜å‚¨åœ¨æ ˆä¸Šï¼Œè€Œå…¶ä»–ç±»å‹çš„å˜é‡åˆ™ä¼šè¢«å­˜å‚¨åœ¨å †ä¸Šã€‚æ ˆé€šå¸¸æ˜¯ç¼–è¯‘å™¨ç®¡ç†çš„ä¸€ä¸ªå¤§å°å›ºå®šçš„ LIFO æ•°æ®ç»“æ„ï¼Œå› ä¸ºé‡Œé¢çš„æ•°æ®æ˜¯è¿ç»­å­˜å‚¨ï¼Œè®¿é—®é€Ÿåº¦å¾ˆå¿«ï¼Œå°±åƒé€šè¿‡ index æ‹¿åˆ°æ•°ç»„é‡Œçš„æ•°æ®ä¸€æ ·ã€‚å †åˆ™æ˜¯åŠ¨æ€çš„æ•°æ®ç»“æ„ï¼Œéœ€è¦æˆ‘ä»¬æ‰‹åŠ¨åˆ†é…å’Œé‡Šæ”¾ï¼Œåœ¨è¿è¡Œæ—¶å †é‡Œé¢çš„æ•°æ®ä¸æ˜¯è¿ç»­å­˜å‚¨åŒæ—¶å¤§å°ä¸å›ºå®šï¼Œæ‰€ä»¥éœ€è¦é€šè¿‡æŒ‡é’ˆæ¥è®¿é—®ï¼Œé€Ÿåº¦æ¯”æ ˆæ›´æ…¢ï¼Œä½†åŒæ ·è¿™ä¸ªç‰¹æ€§ä¹Ÿæ˜¯ä¼˜åŠ¿ï¼Œå †å¯ä»¥å­˜å‚¨åŠ¨æ€åˆ†é…çš„æ•°æ®ï¼Œä¾‹å¦‚å˜é•¿æ•°ç»„ã€å­—ç¬¦ä¸²å’Œå¤æ‚çš„æ•°æ®ç»“æ„ï¼Œè€Œä¸”å¯ä»¥åœ¨ç¨‹åºè¿è¡Œæ—¶åŠ¨æ€åœ°åˆ†é…å’Œé‡Šæ”¾å†…å­˜ã€‚

åœ¨ Rust çš„ä¸–ç•Œé‡Œï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æ—¶å¿…é¡»ç¡®å®šæ¯ä¸ªæ•°æ®ç»“æ„çš„å¤§å°ï¼Œä»è€Œä¿è¯æ ˆä¸Šåˆ†é…å†…å­˜æ—¶ä¸å‘ç”Ÿæº¢å‡ºï¼ŒRust é‡‡ç”¨äº† â€œé›¶æˆæœ¬æŠ½è±¡â€ çš„ç¼–è¯‘æŠ€æœ¯æ¥åœ¨ç¼–è¯‘æ—¶ç¡®å®šè¯¥ç±»å‹çš„å¤§å°ï¼Œæˆ‘ä»¬æœªæ¥å†èŠ Rust çš„ç¼–è¯‘ã€‚

å­—ç¬¦ä¸²ç±»å‹ `&str` å’Œ `String` å°±æ˜¯éå¸¸å…¸å‹çš„ä¾‹å­ï¼Œ`&str`è¡¨ç¤ºä¸€ä¸ªå­—ç¬¦ä¸²çš„åˆ‡ç‰‡ï¼Œå®ƒæ˜¯ä¸€ä¸ªä¸å¯å˜çš„å¼•ç”¨ï¼Œé€šå¸¸å­˜å‚¨åœ¨æ ˆä¸Šã€‚`String`è¡¨ç¤ºä¸€ä¸ªå¯å˜çš„å­—ç¬¦ä¸²ï¼Œé€šå¸¸å­˜å‚¨åœ¨å †ä¸Šã€‚`String`æ˜¯ä¸€ä¸ªæ‹¥æœ‰æ‰€æœ‰æƒçš„ç±»å‹ï¼Œå®ƒåŒ…å«æŒ‡å‘å®é™…å­—ç¬¦ä¸²æ•°æ®çš„æŒ‡é’ˆã€å­—ç¬¦ä¸²é•¿åº¦å’Œå­—ç¬¦ä¸²å®¹é‡ã€‚

é‡æ–°ç†Ÿæ‚‰äº†æ ˆå’Œå †ä¹‹åï¼Œè¿™é‡Œæœ€å¤§çš„ takeaway å°±æ˜¯ Rust ä¸ç®¡æ˜¯å­˜åœ¨æ ˆä¸Šçš„åŸå§‹ç±»å‹æˆ–è€…æ˜¯å­˜åœ¨å †ä¸Šçš„å¯å˜ç±»å‹ï¼Œéƒ½ä¼šéµå¾ªæ‰€æœ‰æƒæ¨¡å‹ï¼Œå„è‡ªçš„å®ç°å„æœ‰ä¸åŒã€‚æˆ‘ä»¬æ¥ä¸‹æ¥å°±ç»ˆäºå¯ä»¥æ¥çœ‹çœ‹æ‰€æœ‰æƒåˆ°åº•æ˜¯ä»€ä¹ˆï¼Ÿ

### æ‰€æœ‰æƒä¸‰åŸåˆ™

1. æ¯ä¸€ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„å˜é‡ä½œä¸ºå®ƒçš„æ‰€æœ‰è€…ã€‚
2. åœ¨åŒä¸€æ—¶é—´å†…ï¼Œå€¼**æœ‰ä¸”ä»…æœ‰ä¸€ä¸ª**æ‰€æœ‰è€…ã€‚
3. å½“æ‰€æœ‰è€…ç¦»å¼€è‡ªå·±çš„**ä½œç”¨åŸŸ(Scope)**æ—¶ï¼Œå®ƒæŒæœ‰çš„å€¼å°±ä¼šè¢«**é‡Šæ”¾(Dropped)**ã€‚

```c
fn to_uppercase(s: String) -> String {
    return s.to_uppercase()
}

fn main() {
    let my_string = String::from("Hello World!");
    let my_uppercase_string = to_uppercase(my_string);
    println!("Uppercase string: {}", my_uppercase_string);
    println!("Original string: {}", my_string); // throw `moved` error
}
```

è¿™ä¸‰åŸåˆ™å…¶å®åœ¨ä¹‹å‰çš„ä¾‹å­æˆ‘ä»¬å·²ç»å¯ä»¥æ€»ç»“å‡ºæ¥äº†ï¼Œ

- Rule #1ï¼šâ€œHello World!â€ å­—ç¬¦ä¸²ä¼šæœ‰å¯¹åº”çš„æ‰€æœ‰è€…ï¼Œä¹Ÿå°±æ˜¯ `my_string`
- Rule #2ï¼šexecution context è¿›å…¥åˆ°`to_uppercase` ä¹‹åï¼Œå­—ç¬¦ä¸²çš„æ‰€æœ‰è€…å˜æˆäº† `s`
- Rule #3ï¼š`s` åœ¨ç¦»å¼€è‡ªå·±çš„ä½œç”¨åŸŸçš„æ—¶å€™ï¼Œå®ƒæŒæœ‰çš„å€¼å°±ä¼šè¢«é‡Šæ”¾ã€‚

å…¶å®å°±æ˜¯è¿™ä¹ˆç®€æ´ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼ŒRust å¦‚ä½•å»å¸®æˆ‘ä»¬é‡Šæ”¾å†…å­˜çš„å‘¢ï¼Ÿ

### å¦‚ä½•é‡Šæ”¾å†…å­˜ï¼Ÿå †ä¸Šç±»å‹çš„ `Drop trait`

é‡Šæ”¾ï¼ˆDropï¼‰çš„æ„æ€ï¼Œå…¶å®æ˜¯å½“å‰è¿™ä¸ªç±»å‹å®ç°äº† Drop trait ï¼ˆtrait æ˜¯ä¸ªæ–°æ¦‚å¿µï¼Œæˆ‘ä»¬å¯ä»¥å§‘ä¸”æŠŠå®ƒå½“æˆ Java çš„ Interfaceï¼‰ï¼Œåœ¨å˜é‡çš„ç”Ÿå‘½å‘¨æœŸåˆ°å°¾å£°çš„æ—¶å€™ï¼ŒRust å¸®æˆ‘ä»¬è°ƒç”¨äº† `drop` å‡½æ•°æ¥é‡Šæ”¾å†…å­˜ã€‚æ¯”å¦‚ä¸‹é¢ String å°±ä¼šå®ç° Drop traitã€‚ï¼ˆå£°æ˜ï¼šæ­¤ä¾‹å­æ˜¯ ChatGPT ç”Ÿæˆçš„ç¤ºä¾‹å®ç°ï¼Œé [String æºç ](https://github.com/rust-lang/rust/blob/master/library/alloc/src/string.rs)ï¼‰

```c
pub trait Drop {
    fn drop(&mut self);
}

impl Drop for String {
    fn drop(&mut self) {
        unsafe {
            let ptr = self.as_mut_vec().as_mut_ptr();
            let len = self.len();
            std::mem::forget(self);
            std::alloc::dealloc(ptr, Layout::from_size_align_unchecked(len, 1));
        }
    }
}
```

åœ¨æˆ‘ä»¬æ‰‹åŠ¨é‡Šæ”¾ä¹‹å‰ï¼Œæˆ‘ä»¬ä¸å¿…æ‹…å¿ƒå†…å­˜æ³„æ¼ã€‚è¿™ç§æ–¹å¼è¢«ç§°ä¸º RAIIï¼ˆèµ„æºè·å–å³åˆå§‹åŒ–ï¼‰ï¼Œå®ƒä¿è¯äº†åœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œæ‰€æœ‰çš„èµ„æºéƒ½ä¼šè¢«é‡Šæ”¾ã€‚å…¶å® C++ ä¹Ÿæœ‰ RAIIï¼Œæ¯”å¦‚åœ¨ä¸€ä¸ª Class çš„ deconstructor é˜¶æ®µé‡Œå…³æ‰åˆå§‹åŒ–æ—¶å¼€å¯çš„ file descriptor ç­‰ç­‰ï¼Œä½†å¹¶ä¸åƒ Rust æ˜¯åœ¨è¯­è¨€å±‚é¢å¿…é¡»è¦å®ç° Drop trait æ¥ä¿è¯æ‰€æœ‰æƒï¼Œç›¸æ¯”ä¹‹ä¸‹ Rust å°±ä¸¥æ ¼å¾—å¤šã€‚

é™¤äº† `Drop trait`, è¿˜æœ‰ `Borrow trait` , `Deref trait` , `AsRef trait` ç­‰éƒ½å’Œæ‰€æœ‰æƒæ§åˆ¶æœ‰å…³ï¼Œä¸åŒçš„æ•°æ®ç»“æ„å®ç°è¿™äº› traitï¼Œèƒ½ç¡®ä¿ Rust åœ¨è¯­è¨€çº§åˆ«ä¸Šå¯¹æ‰€æœ‰æƒçš„æ§åˆ¶æ¥ä¿è¯å†…å­˜å®‰å…¨ã€‚

é‚£æ—¢ç„¶æˆ‘ä»¬çŸ¥é“äº†å¦‚ä½•å»é‡Šæ”¾å†…å­˜ï¼Œé‚£å¯ä»¥é‡æ–°çœ‹çœ‹åœ¨ä»€ä¹ˆæ—¶å€™å»è°ƒç”¨ `drop` å‡½æ•°ã€‚

### ä»€ä¹ˆæ˜¯ `drop` ï¼Ÿç†è§£ä½œç”¨åŸŸ

ä½œç”¨åŸŸæœ¬èº«çš„æ¦‚å¿µå’Œå…¶ä»–è¯­è¨€æ˜¯ä¸€è‡´çš„ï¼Œæ¯”å¦‚ä¸‹é¢ç®€å•çš„ä¾‹å­ã€‚

```c
fn main() {
	{
		let x = 5; // define a variable x here
		// use variable x here
	} // variable x goes out of scope and gets dropped here
	// x variable doesn't exist here anymore
}
```

`x` ä¼šåœ¨ç¦»å¼€å…¶ä½œç”¨åŸŸçš„æ—¶å€™è¢«é‡Šæ”¾ã€‚æˆ‘ä»¬æ¥çœ‹çœ‹æ›´å¤æ‚çš„ä¾‹å­ï¼Œæ¯”å¦‚é‡æ–°çœ‹çœ‹å­—ç¬¦ä¸²æ‹¼æ¥çš„`+` ï¼Œä¸ºä»€ä¹ˆå’Œå…·ä½“ä»€ä¹ˆæ—¶å€™ `+` å·¦è¾¹çš„ String æ‰€æœ‰æƒä¼šè¢«é‡Šæ”¾æ‰ã€‚

```c
// pub fn push_str(&mut self, string: &str) {
//     self.vec.extend_from_slice(string.as_bytes())
// }

// impl Add<&str> for String {
//     type Output = String;
//     #[inline]
//     fn add(mut self, other: &str) -> String {
//         self.push_str(other);
//         self
//     }
// }

fn main() {
    let s1 = String::from("Hello");
		let s2 = String::from(" World!");
		let s3 = s1 + &s2; // same as `s1.add(&s2)`
    println!("{}", s3);
}

```

å…¶å®åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œ `s1 + &s2` å…¶å®å°±æ˜¯ `s1.add(&s2)` ï¼ŒèƒŒåè°ƒç”¨äº† String çš„ `add()` æ–¹æ³• ï¼ˆ[æºç ](https://github.com/rust-lang/rust/blob/master/library/alloc/src/string.rs#L2291-L2338)ï¼‰ã€‚é‡Œé¢æœ‰è¿™ä¹ˆå‡ æ­¥ï¼š

1. `add` ä¸­çš„ `mut self` ä¼šå æœ‰ `"Hello"` çš„æ‰€æœ‰æƒï¼Œæ¥ç€è°ƒç”¨äº† `push_str`
2. `push_str` çš„ self ç±»å‹æ˜¯å¯å˜å¼•ç”¨ `&mut self` ï¼Œå¼•ç”¨æ˜¯ä¸ä¼šå ç”¨æ‰€æœ‰æƒçš„ï¼Œæ‰€ä»¥`"Hello"` çš„æ‰€æœ‰æƒä»åœ¨ä¸Šä¸€å±‚çš„ self ä¸­
3. `self.vec.extend_from_slice(string.as_bytes())` è¿™é‡Œæ˜¯å¯¹ Vector è¿›è¡Œæ“ä½œï¼Œä¹Ÿä¸ä¼šæœ‰æ‰€æœ‰æƒçš„å˜åŠ¨ï¼Œä½†å°†ä¹‹å‰ `"Hello"` å’Œ  `" World!"` æ‹¼æ¥èµ·æ¥åˆ›å»ºäº†æ–°çš„ String
4. è¿™ä¸ªæ–°çš„ String `Hello World!` è¢«èµ‹å€¼åˆ°äº†åŸæœ¬çš„ `add` å‡½æ•°çš„ `mut self` ä¸­ï¼Œæ­¤æ—¶ `Hello` çš„ç”Ÿå‘½å‘¨æœŸç»“æŸ
5. `add` æ‰§è¡Œç»“æŸï¼Œæ–°çš„ String è¢« returnï¼Œ `"Hello"` çš„æ‰€æœ‰æƒè¢«é‡Šæ”¾ï¼Œè°ƒç”¨ `drop` å‡½æ•°æ¥é‡Šæ”¾ä¹‹å‰å ç”¨çš„å†…å­˜ã€‚

é€šè¿‡è¿™ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¯¹ä»€ä¹ˆæ—¶å€™è°ƒç”¨ `drop` å‡½æ•°æœ‰ä¸ªåˆæ­¥çš„ç†è§£ã€‚

### é™¤äº† `Drop` å‘¢ï¼Ÿæ ˆä¸Šç±»å‹çš„ `Copy trait`

ä¸Šé¢è®²åˆ°çš„éƒ½æ˜¯å­˜æ”¾åœ¨ Heap ä¸Šçš„ç±»å‹ï¼Œ `drop` çš„å…·ä½“å®ç°ä¹Ÿæ˜¯å¯¹ Heap ä½¿ç”¨çš„å›æ”¶ï¼Œé‚£åœ¨ Stack ä¸Šçš„ç±»å‹æ€ä¹ˆå»å¤„ç†æ‰€æœ‰æƒå‘¢ï¼Ÿæ¯”å¦‚ä¸‹é¢ `i32` çš„ä¾‹å­ï¼Œä½ è§‰å¾—ä¼šæœ‰ç¼–è¯‘é”™è¯¯ä¹ˆï¼Ÿ

```c
fn main() {
    let x = 5;  // x is an i32, allocated on the stack
    foo(x);     // call function foo and pass x to it
    println!("{}", x);  // will it compile?
}

fn foo(y: i32) {
    println!("{}", y);
}  // y goes out of scope and is dropped
```

ç­”æ¡ˆæ˜¯ä¸ä¼šæœ‰ç¼–è¯‘é”™è¯¯ï¼Œèƒ½æ­£å¸¸è¿è¡Œã€‚é‚£ `i32` ç¬¦åˆæ‰€æœ‰æƒä¸‰åŸåˆ™ä¹ˆï¼Ÿç­”æ¡ˆæ˜¯ç¬¦åˆçš„ã€‚å› ä¸ºä»–ä»¬å®ç°äº† `[Copy](https://doc.rust-lang.org/std/marker/trait.Copy.html)` è¿™ä¸ª traitï¼Œå®ƒæ˜¯ Rust ä¸­çš„ä¸€ä¸ªç‰¹æ®Š traitï¼Œæ ‡è®°ä¸º `Copy`çš„ç±»å‹åœ¨è¿›è¡Œèµ‹å€¼ã€ä¼ é€’å‡½æ•°å‚æ•°å’Œè¿”å›å€¼æ—¶ï¼Œä¼šè¢«è‡ªåŠ¨å¤åˆ¶è€Œä¸æ˜¯ç§»åŠ¨å…¶æ‰€æœ‰æƒã€‚è¿™æ„å‘³ç€ï¼Œå½“æ ‡è®°ä¸º `Copy`çš„ç±»å‹çš„å€¼è¢«èµ‹å€¼ç»™å…¶ä»–å˜é‡ã€ä¼ é€’ç»™å‡½æ•°æˆ–ä»å‡½æ•°ä¸­è¿”å›æ—¶ï¼ŒåŸå§‹å˜é‡ä»ç„¶ä¿ç•™æ‰€æœ‰æƒï¼ŒåŒæ—¶å®ƒä»¬çš„å‰¯æœ¬ä¹Ÿä¼šè¢«åˆ›å»ºå¹¶åˆ†é…åˆ°æ–°çš„ä½ç½®ä¸Šã€‚æ ‡è®°ä¸º `Copy`çš„ç±»å‹é€šå¸¸æ˜¯ç®€å• vector ç±»å‹ï¼ˆä¾‹å¦‚ `i32`, `i64`, `float`, `bool` ç­‰ï¼‰æˆ–ä¸åŒ…å«ä»»ä½•æ‰€æœ‰æƒä¿¡æ¯çš„ç»“æ„ä½“æˆ–æšä¸¾ç±»å‹ã€‚

æ‰€ä»¥åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ `i32` ç±»å‹çš„ `x` åœ¨ä¼ å…¥ `foo` çš„æ—¶å€™å°±å·²ç»è¢«è‡ªåŠ¨å¤åˆ¶åˆ°äº† `y` æ‰€ä»¥å°±ç®—åœ¨ `foo` æ‰§è¡Œç»“æŸå `y` çš„é‡Šæ”¾å¹¶ä¸ä¼šå½±å“ `x` çš„æ‰€æœ‰æƒã€‚

æˆ‘ä»¬å¯¹æ‰€æœ‰æƒçš„ç†è§£å¯ä»¥å…ˆæš‚æ—¶æ­¢æ­¥äºæ­¤ï¼Œæœªæ¥èŠå¦å¤–ä¸¤ä¸ªè¯é¢˜çš„æ—¶å€™è¿˜ä¼šä¸æ–­çš„å›åˆ°æ‰€æœ‰æƒçš„æ¦‚å¿µï¼Œå› ä¸ºè¿™æ˜¯ Rust å†…å­˜ç®¡ç†çš„åŸºç¡€ã€‚æœ€åï¼Œæˆ‘ä»¬å¯ä»¥ä»å‡ ä¸ªå…¸å‹çš„å†…å­˜é—®é¢˜çš„è§’åº¦ï¼Œæ¥çœ‹çœ‹æ‰€æœ‰æƒä¸‰åŸåˆ™åŠ ä¸Šå€Ÿç”¨æ£€æŸ¥æœºåˆ¶æ˜¯å¦‚ä½•è§£å†³è¿™äº›é—®é¢˜çš„ã€‚

## Thatâ€™s it? é‚£æ‰€æœ‰æƒå…·ä½“å¦‚ä½•ä¿è¯å†…å­˜å®‰å…¨å‘¢ï¼Ÿ

æ—¢ç„¶æˆ‘ä»¬å¤§æ¦‚ç†è§£äº†æ‰€æœ‰æƒï¼Œé‚£å®ƒæ˜¯å¦‚ä½•èƒ½ä¿è¯å†…å­˜å®‰å…¨çš„å‘¢ï¼Ÿæœ‰å…³å†…å­˜çš„é—®é¢˜å¤šå¦‚ç‰›æ¯›ï¼Œè¿™ä¹ˆç®€å•çš„3ä¸ªåŸåˆ™å°±èƒ½å®Œå…¨è§£å†³æ‰ä¹ˆï¼Ÿæˆ‘ä»¬å¯ä»¥å…·ä½“çœ‹çœ‹å‡ ä¸ª C / C++ é‡Œé¢çš„å¸¸è§å†…å­˜é—®é¢˜ï¼ŒRust æ€ä¹ˆå»é¿å…ä»–ä»¬çš„ã€‚

### åŒé‡é‡Šæ”¾ï¼ˆDouble Freeï¼‰å’Œå†…å­˜æ³„æ¼ï¼ˆMemory Leaksï¼‰

åŒé‡é‡Šæ”¾æ˜¯éå¸¸å¸¸è§è€Œåˆéšæ™¦çš„å†…å­˜é—®é¢˜ï¼Œæ¯”å¦‚ C++ åœ¨è¿è¡Œæ—¶åŠ¨æ€åˆ†é…äº†å†…å­˜ï¼Œè€Œæ‰‹åŠ¨å»å¤šæ¬¡é‡Šæ”¾åŒä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å†…å­˜æ—¶ï¼Œå°±ä¼šå¯¼è‡´å®Œå…¨ä¸å¯é¢„æµ‹çš„è¡Œä¸ºã€‚å› ä¸ºç¬¬äºŒæ¬¡é‡Šæ”¾å¹¶ä¸çŸ¥é“æ­¤æ—¶å†…å­˜é‡Œå­˜çš„æ˜¯ä»€ä¹ˆï¼Œç¨‹åºå¯èƒ½ç«‹åˆ»å´©æºƒï¼Œæˆ–è€…åœ¨è¿è¡Œä¸€æ®µæ—¶é—´ä¹‹åæ‰å´©æºƒï¼Œç”šè‡³ä¼šå¯¼è‡´æ•´ä¸ªç³»ç»Ÿå´©æºƒã€‚

```c
int main() {
	int* ptrA = new int(5);
	int* ptrB = new int(6);

	ptrB = ptrA;
  // ... a lot of logic and wanna free the memory at last
	delete ptrA;
	delete ptrB; // deleting ptrA again -> Double Free & Memory Leak
}
```

ä¸Šé¢è¿™ä¸ªç®€å•çš„ä¾‹å­æ˜¯åŒæ—¶è§£é‡Šäº†åŒé‡é‡Šæ”¾åŠ ä¸Šå†…å­˜æ³„æ¼ï¼Œ `ptrB` æŒ‡å‘ `ptrA` çš„å†…å­˜åœ°å€ä¹‹åï¼Œæœ€å `delete ptrB` æ—¢æ²¡æœ‰å°†åŸæœ¬æŒ‡å‘çš„å†…å­˜é‡Šæ”¾æ‰ï¼ŒåŒæ—¶è¿˜é”™è¯¯åœ°ç¬¬äºŒæ¬¡é‡Šæ”¾äº† `ptrA` æŒ‡å‘çš„åœ°å€ã€‚å½“ç„¶ C++ æœ‰æ™ºèƒ½æŒ‡é’ˆç­‰æœºåˆ¶æ¥é¿å…é—®é¢˜ï¼Œè€Œåœ¨ Rust ä»è¯­è¨€å±‚é¢å»é¿å…äº†è¿™ä¸ªé—®é¢˜ï¼Œæ‰€æœ‰æƒæœºåˆ¶å’Œ `Drop` trait çš„å®ç°å¸®ç”¨æˆ·å»é‡Šæ”¾å†…å­˜ï¼ŒåŒæ—¶é€šè¿‡ç”Ÿå‘½å‘¨æœŸçŸ¥é“ä»€ä¹ˆæ—¶å€™æ¥é‡Šæ”¾å†…å­˜ï¼Œä¸éœ€è¦æˆ‘ä»¬æ‰‹åŠ¨å»é‡Šæ”¾ã€‚

### é‡æŒ‡é’ˆ Wild Pointers

é‡æŒ‡é’ˆæ˜¯æŒ‡æ²¡æœ‰è¢«åˆå§‹åŒ–çš„æŒ‡é’ˆï¼Œæˆ–è€…å†…å­˜ç©ºé—´å·²ç»è¢«é‡Šæ”¾çš„æŒ‡é’ˆï¼ˆè¿™æ—¶ä¹Ÿå«å‚æ‚¬æŒ‡é’ˆ Dangling Pointerï¼‰ã€‚æˆ‘ä»¬æ¥çœ‹çœ‹ C++ çš„ä¾‹å­ï¼š

```c
int* dangling_pointer() {
    int x = 5; // value 5 is on stack
    int* ptr = &x;
    return ptr; // the value of x has been freed
}

int main() {
	// case 1: uninitialized pointer
	int *ptrA;
  cout << *ptrA << endl;  // accessing unknown memory, which may result in strange output

	// case 2: dangling pointer
	int* ptrB = dangling_pointer();

	return 0
}
```

è¿™é‡Œ `ptrA` æŒ‡å‘äº†ä¸€ä¸ªæœªè¢«åˆå§‹åŒ–çš„å†…å­˜åœ°å€ï¼Œè€Œ `ptrB` åˆ™æŒ‡å‘äº†ä¸€ä¸ªå·²ç»è¢«é‡Šæ”¾çš„å†…å­˜åœ°å€ï¼Œä¸¤è€…éƒ½ä¼šå¼•å‘éå¸¸åŒªå¤·æ‰€æ€çš„ç¨‹åºå´©æºƒã€‚å¦‚æœæˆ‘ä»¬å°†ä¸Šé¢çš„ç¨‹åºç”¨ Rust å®ç°ï¼š

```c
// case 1: uninitialized pointe
fn main() {
	  let p: *mut i32 = std::ptr::null_mut();
    println!("{}", *p);  // error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block
}
```

Rust åœ¨ç¼–è¯‘æ—¶ä¼šæ£€æŸ¥ä¸€ä¸ªæŒ‡é’ˆæ˜¯å¦è¢«åˆå§‹åŒ–ã€‚

```c
// case 2: dangling pointer
fn dangling_pointer() -> &i32 { // error[E0106]: missing lifetime specifier
    let x = 5;
    &x // error: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
}

fn main() {
    let ptr = dangling_pointer();
}
```

åŒæ ·ï¼ŒRust åœ¨ç¼–è¯‘æ—¶å°±ä¼šæ£€æµ‹ï¼Œåœ¨ return çš„è¿™ä¸ª `&x` æ˜¯ä¸€ä¸ª borrowed valueï¼Œè€Œåœ¨è¿”å›æ—¶å®ƒçš„å€¼å·²ç»æ²¡æœ‰äº†ï¼Œè¿™ä¸ªæ£€æŸ¥å°±æ˜¯ Rust ä¸­è‘—åçš„å€Ÿç”¨æ£€æŸ¥ ï¼ˆBorrow Checker)ã€‚

### ç¼“å†²åŒºæº¢å‡ºï¼ˆBuffer Overflowï¼‰

å†™è¿‡ C / C++ çš„æœ‹å‹ä»¬å¯èƒ½ä¼šå¾ˆç†Ÿæ‚‰ä¸‹é¢è¿™ä¸ªè‡­åæ˜­è‘—çš„ç¼“å†²åŒºæº¢å‡ºä¾‹å­ï¼š

```c
#include <iostream>
#include <cstring>

int main() {
    char buffer[5] = {0};
    std::strcpy(buffer, "123456789");
    std::cout << buffer << std::endl;
    return 0;
}
```

ç”±äº C / C++ æ˜¯æ‰‹åŠ¨ç®¡ç†å†…å­˜ï¼Œè¿™é‡Œçš„ `buffer` å…¶å®åªæ˜¯æŒ‡å‘äº†ä¸€ä¸ªå†…å­˜åœ°å€ï¼Œæ²¡æœ‰é™åˆ¶çœŸæ­£çš„å¤§å°ï¼Œæ‰€ä»¥å¦‚æœä½¿ç”¨ `strcpy` è€Œä¸æ˜¯ `strncpy` ï¼Œé‚£å¯ä»¥ç»§ç»­å¾€å†…å­˜ä¸Šå†™è¶…è¿‡è¿™é‡Œ buffer é•¿åº¦çš„æ•°æ®ï¼Œè€Œé€ æˆç¼“å†²è®¸æº¢å‡ºã€‚è¿™é‡Œæ¨è CSAPP çš„ Attack Labï¼Œ å¯ä»¥åˆ©ç”¨ Buffer Overflow æ¥è¿›è¡Œæ”»å‡»ï¼Œååˆ†æœ‰è¶£ã€‚

æˆ‘ä»¬çœ‹çœ‹ Rust æ€ä¹ˆå»é˜²æ­¢è¿™ä¸ªå†…å­˜é—®é¢˜çš„ï¼š

```c
fn main() {
    let mut buffer = vec![0u8; 5];
    let input = [1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8];

    for (i, x) in input.iter().enumerate() {
        buffer[i] = *x;
    }
}
```

åœ¨ Rust ä¸­ï¼Œä¸Šé¢çš„ç¨‹åºæ˜¯å¯ä»¥ç¼–è¯‘é€šè¿‡çš„ï¼Œä½†æ˜¯åœ¨è¿è¡Œæ—¶ä¼šæŠ¥é”™ `thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 5', main.rs:6:9` ï¼Œè¿™æ˜¯å› ä¸º Rust åœ¨æ•°ç»„å’Œåˆ‡ç‰‡éƒ½å†…ç½®äº†è¾¹ç•Œæ£€æŸ¥æœºåˆ¶ï¼Œæ¯”å¦‚ Rust å¯¹äºå›ºå®šé•¿åº¦çš„æ•°ç»„ä¼šåœ¨ç¼–è¯‘æ—¶[ç¡®å®šå…¶å¤§å°](https://doc.rust-lang.org/std/primitive.slice.html#method.len)ï¼Œåœ¨è¿è¡Œæ—¶å°±å¯ä»¥æ£€æµ‹æ˜¯å¦è¶Šç•Œï¼Œç„¶åç›´æ¥æŠ›å‡º panic é”™è¯¯æ¥é€€å‡ºç¨‹åºï¼Œfail earlyï¼Œä»è€Œé¿å…äº†åç»­å¯èƒ½çš„æ”»å‡»ã€‚

## å†™åœ¨æœ€å

å¤ªé˜³åº•ä¸‹æ— æ–°äº‹ï¼ŒRust çš„æ‰€æœ‰æƒå’Œå€Ÿç”¨æ£€æŸ¥ä¹Ÿä¸æ˜¯å…¨æ–°çš„ä¸œè¥¿ï¼ŒC++ è€æ‰‹ä¼šè¯´æœ‰å¾ˆå¤šæœºåˆ¶å¯ä»¥å®ç°åŒæ ·å®‰å…¨çš„ä»£ç ï¼šæ™ºèƒ½æŒ‡é’ˆï¼Œå€Ÿç”¨è®¡æ•°å’Œç¬¬ä¸‰æ–¹åº“ï¼ˆå¦‚ Boostï¼‰ç­‰ï¼Œéµå¾ªæ›´ä¸¥æ ¼çš„ä»£ç é£æ ¼å’Œä»£ç è¯„å®¡æµç¨‹ï¼Œç­‰ç­‰ã€‚ä½†ä¸å¾—ä¸è¯´ï¼Œåœ¨è®¾è®¡ä¸Šå°†å†…å­˜å®‰å…¨ç½®äºé»˜è®¤çŠ¶æ€çš„ Rustï¼Œç¼–å†™èµ·æ¥æ¯” C++ è¦å°‘äº†å¾ˆå¤šå¿ƒæ™ºè´Ÿæ‹…å’Œæ—¶é—´æˆæœ¬ã€‚

äººæ˜¯æ‰€æœ‰è½¯ä»¶å·¥ç¨‹æ‰€æœ‰ç¯èŠ‚é‡Œæœ€è–„å¼±çš„ä¸€ç¯ï¼Œé‚£åœ¨ ChatGPT æ›¿ä»£æ‰äººç¼–å†™ç¨‹åºé‚£ä¸€åˆ»ä¹‹å‰ï¼ŒRust çœŸçš„æ˜¯ä¸€ä¸ªè®©äººæ›´å®‰å¿ƒçš„è¯­è¨€ã€‚æˆ‘ä»¬ä¸‹æ¬¡åœ¨ç»§ç»­èŠèŠ Rust çš„ç”Ÿå‘½å‘¨æœŸå’Œç¼–è¯‘ã€‚Until next time!